[{"title":"RAG知识库和Tools工具","url":"/2025/10/27/RAG%E7%9F%A5%E8%AF%86%E5%BA%93%E5%92%8CTools%E5%B7%A5%E5%85%B7/","content":"RAG知识库RAG的作用和入门RAG全称为 Retrieval Augmented Generation，翻译过来是检索增强生成。因为大模型训练结束之后不会再加入新的数据，但是用户肯定想要最新的数据，而且专业领域的知识大模型也是不清楚的，就需要外接知识库来增强大模型的生成能力。大模型接入知识库后的工作流程是：\n\n用户在应用中提出问题\n在知识库寻找相关数据，返回相关的内容\n组织prompt并发送给大模型\n生成结果并返回响应知识库的存储数据一般使用的是向量数据库。简单来说就是知识库会把数据变成成百上千个维度，类似与向量的东西，然后计算向量的余弦相似度，将数据结构化就便于匹配数据。知识库还需要文本分割器把文档分成小的文本片段，这些片段又要借助向量模型，把它们转变成向量，然后存储到向量数据库中。\n\n那么搜索知识库的过程就是，用户提交消息，向量模型吧消息转换成向量与数据库中比对，计算余弦相似值，越大说明越相关度越高，我们可以设置相似度高于多少才可被检索，检索出来的信息一起发给大模型，生成结果。\n\n简单使用步骤\n引入rag的依赖\n在资源中导入知识库需要的资料\n用ClassPathDocumentLoader将文档加载进内存\n构建向量数据库对象EmbeddingStore\n分割文档并向量化，存入数据库\n\n@Bean  public EmbeddingStore store()&#123;    //1.加载文档进内存    List&lt;Document&gt; documents = ClassPathDocumentLoader.loadDocuments(&quot;content&quot;);    //2.构建向量数据库操作对象  操作的是内存版本的向量数据库    InMemoryEmbeddingStore store = new InMemoryEmbeddingStore();    //3.构建一个EmbeddingStoreIngestor对象,完成文本数据切割,向量化, 存储    EmbeddingStoreIngestor ingestor = EmbeddingStoreIngestor.builder()            .embeddingStore(store)            .build();    ingestor.ingest(documents);    return store;  &#125;\n\n构建ContentRetriever对象\n\n@Beanpublic ContentRetriever contentRetriever(EmbeddingStore store)&#123;  return EmbeddingStoreContentRetriever.builder()          .embeddingStore(store)//设置向量数据库操作对象          .minScore(0.5)//设置最小分数          .maxResults(3)//设置最大片段数量          .build();&#125;\n\n配置ContentRetriever对象（书接上回，就是在@aiservice注解上加一行\n\n@AiService(      wiringMode = AiServiceWiringMode.EXPLICIT,//手动装配      chatModel = &quot;openAiChatModel&quot;,//指定模型      streamingChatModel = &quot;openAiStreamingChatModel&quot;,      //chatMemory = &quot;chatMemory&quot;,//配置会话记忆对象      chatMemoryProvider = &quot;chatMemoryProvider&quot;,//配置会话记忆提供者对象      contentRetriever = &quot;contentRetriever&quot;//配置向量数据库检索对象)\n\nRAG使用到的核心api1. 文档加载器作用是把磁盘或者网络中的数据加载进程序，常见的有三类：\n\n\nFileSystemDocumentLoader, 根据本地磁盘绝对路径加载\nClassPathDocumentLoader，相对于类路径加载\nUrlDocumentLoader，根据url路径加载\n\n\n2. 文档解析器用于解析文档中的内容，把原本非纯文本数据转化成纯文本。比如初始的文档是pdf格式的，可以把它转为文本格式。常见的有以下：\n\n\nTextDocumentParser，解析纯文本格式的文件\nApachePdfBoxDocumentParser，解析pdf格式文件\nApachePoiDocumentParser，解析微软的office文件，例如DOC、PPT、XLS\nApacheTikaDocumentParser（默认），几乎可以解析所有格式的文件（在纯PDF文件方面的表现没有那么优秀）\n\n\n使用方法：引入依赖，在EmbeddingStore中指定解析器\n3. 文档分割器常见的有以下\n\n\nDocuemntByParagraphSplitter，按照段落分割文本\nDocumentByLineSplitter，按照行分割文本\nDocumentBySentenceSplitter，按照句子分割文本\nDocumentByWordSplitter，按照词分割文本\nDocumentByCharacterSplitter，按照固定数量的字符分割文本\nDocumentByRegexSplitter，按照正则表达式分割文本\nDocumentSplitters.recursive(…)(默认)，递归分割器,优先段落分割，再按照行分割，再按照句子分割，再按照词分割\n\n\n@Beanpublic EmbeddingStore store()&#123;  //1.加载文档进内存  //List&lt;Document&gt; documents = ClassPathDocumentLoader.loadDocuments(&quot;content&quot;);  //加载文档的时候指定解析器  List&lt;Document&gt; documents = ClassPathDocumentLoader.loadDocuments(&quot;content&quot;,new ApachePdfBoxDocumentParser());  //2.构建向量数据库操作对象  操作的是内存版本的向量数据库  InMemoryEmbeddingStore store = new InMemoryEmbeddingStore();  //构建文档分割器对象  DocumentSplitter ds = DocumentSplitters.recursive(500,100);  //3.构建一个EmbeddingStoreIngestor对象,完成文本数据切割,向量化, 存储  EmbeddingStoreIngestor ingestor = EmbeddingStoreIngestor.builder()          .embeddingStore(store)          .documentSplitter(ds)           .build();  ingestor.ingest(documents);  return store;&#125;\n\n4. 向量模型前面用到的向量模型没有那么精准，可以自己外接专业的模型。使用方法如下：\n\n\n在配置文件配置向量模型\n在EmbeddingStore和ContentRetriever指定向量模型（存储和检索用）\n\n\n5. 向量数据库EmbeddingStore虽然可用，但是数据都是存在内存里的，不太符合实际开发需求，所以要自己编写一个，将数据存到外部数据库中。使用方法如下（使用redis数据库）:\n\n部署一个扩展了redissearch的redis\n引入依赖\n在配置文件配置向量数据库连接信息\n注入RedisEmbeddingStore对象使用\n\n@Autowiredprivate RedisEmbeddingStore redisEmbeddingStore;//@Beanpublic EmbeddingStore store()&#123;//embeddingStore的对象, 这个对象的名字不能重复,所以这里使用store    //1.加载文档进内存    //List&lt;Document&gt; documents = ClassPathDocumentLoader.loadDocuments(&quot;content&quot;);    List&lt;Document&gt; documents = ClassPathDocumentLoader.loadDocuments(&quot;content&quot;,new ApachePdfBoxDocumentParser());    //List&lt;Document&gt; documents = FileSystemDocumentLoader.loadDocuments(&quot;C:\\\\Users\\\\Administrator\\\\ideaProjects\\\\consultant\\\\src\\\\main\\\\resources\\\\content&quot;);    //2.构建向量数据库操作对象  操作的是内存版本的向量数据库    //InMemoryEmbeddingStore store = new InMemoryEmbeddingStore();    //构建文档分割器对象    DocumentSplitter ds = DocumentSplitters.recursive(500,100);    //3.构建一个EmbeddingStoreIngestor对象,完成文本数据切割,向量化, 存储    EmbeddingStoreIngestor ingestor = EmbeddingStoreIngestor.builder()            //.embeddingStore(store)            .embeddingStore(redisEmbeddingStore)            .documentSplitter(ds)            .embeddingModel(embeddingModel)            .build();    ingestor.ingest(documents);    return redisEmbeddingStore;&#125;@Beanpublic ContentRetriever contentRetriever(/*EmbeddingStore store*/)&#123;    return EmbeddingStoreContentRetriever.builder()            .embeddingStore(redisEmbeddingStore)            .minScore(0.5)            .maxResults(3)            .embeddingModel(embeddingModel)            .build();&#125;\n\n\nTools工具Tools工具用于函数调用，下图是其工作形式\n使用前的准备工作\n准备数据库及数据表，并编写配置\n引入数据库相关依赖（lombok，mysql，mybatis）\n准备实体类\n开发service层和mapper层，完成所需要的服务和对数据库的操作\n\n使用tools让大模型帮我们调用函数\n准备tools方法\n\nimport com.itheima.consultant.pojo.Reservation;import com.itheima.consultant.service.ReservationService;import dev.langchain4j.agent.tool.P;import dev.langchain4j.agent.tool.Tool;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.time.LocalDateTime;@Componentpublic class ReservationTool &#123;  @Autowired  private ReservationService reservationService;  //1.工具方法: 添加预约信息  @Tool(&quot;预约志愿填报服务&quot;)  public void  addReservation(          @P(&quot;考生姓名&quot;) String name,         @P(&quot;考生性别&quot;) String gender,          @P(&quot;考生手机号&quot;) String phone,          @P(&quot;预约沟通时间,格式为: yyyy-MM-dd&#x27;T&#x27;HH:mm&quot;) String communicationTime,          @P(&quot;考生所在省份&quot;) String province,          @P(&quot;考生预估分数&quot;) Integer estimatedScore  )&#123;      Reservation reservation = new Reservation(null,name,gender,phone, LocalDateTime.parse(communicationTime),province,estimatedScore);      reservationService.insert(reservation);  &#125;  //2.工具方法: 查询预约信息  @Tool(&quot;根据考生手机号查询预约单&quot;)  public Reservation findReservation(@P(&quot;考生手机号&quot;) String phone)&#123;      return reservationService.findByPhone(phone);  &#125;&#125;\nTool注解用于对方法的作用进行描述，P注解用于对方法的参数进行描述，使LangChain4j能通过反射的方式获取到Tool注解中的内容一并发送给大模型。2. 配置tools方法在@aiservice注解上加一行tools &#x3D; “reservationTool”\n\nlangchain4j完结撒花~后续还可能根据项目需要，学习更精细的功能。\n","tags":["学习记录"]},{"title":"blog使用方法存档","url":"/2025/10/22/blog%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%AD%98%E6%A1%A3/","content":"本来是使用github pages直接搭建一个简单的静态页面作为个人博客，可是自动写入时间戳的功能一直把握不好，还是得自己填写。为了监督自己不偷懒，思来想去还是改用hexo的博客框架，并且挑选了别人写好的皮肤，太可爱了，很感谢，写博客都有动力了。为了配上好看的主题，我准备学习md的语法，其实之前一直都知道，但是莫名有一种畏难心理，实际上它就是很简单啊！打代码也是一样的，熟练之后实际上没多难呢~而且还漂亮整洁很多，我试过用用标签形式调整blog格式，还是有点不尽人意而且较为麻烦，编写的时候会不由自主按流水账形式，但是用了md语法写，就会把它写的很格式化，看起来也有条理。（虽然现在写的还不怎么样）一步一步来吧！\n1.blog配置项示例title: 标题date: 自动填入tags: 文本cover: 封面图片链接\n\n2.markdown语法示例特别注意！：列表、标题和块引用符号后面需要加一个空格，不要忘记了\n标题篇~主标题：主标题 ===\n副标题：副标题---\n一级标题： # 一级标题二级标题：## 二级标题三级标题：### 三级标题列表篇~\n有序列表： 1. 第一条\n\n\n无序列表： - 无序表\n\n代码篇~行内代码:  &#96;代码块：&#x2F;&#x2F;&#96;&#96;&#96;\n 多行代码\n &#x2F;&#x2F;&#96;&#96;&#96;\n划线篇~分割线： ---\n\n强调文本~斜体：*粗体 ：**删除线：~~\n块引用~\nlove markdownlove cs\n\n&gt; 内容内容2\n\n链接or图片篇~百度 ：[文本](链接)：![文本](链接)\n表格篇~\n\n\n学号\n姓名\n成绩\n\n\n\n1\na\n93\n\n\n2\nb\n91\n\n\n3\nc\n90\n\n\n\n小结小结就是！开源精神很伟大！\n","tags":["教程"]},{"title":"自学Langchain4j","url":"/2025/10/23/%E8%87%AA%E5%AD%A6Langchain4j/","content":"Langchain4j 简易教程1.Langchain4j的介绍  主流的调用大模型的工具库有两种，一是 Langchain4j，二是SpringAI。简单来说Langchain4j是java调用大模型的工具库，使大模型和传统的软件深度融合。今天学习简单的 Langchain4j的应用。\n\n2.快速入门——使用Spring整合 Langchain4j\n创建SpringBoot项目\n引入 Langchain4j起步依赖\n在application.yml配置大模型信息，便于调用\n编写controller层，调用大模型\n\n  @RestControllerpublic class ChatController &#123;    @Autowired    private OpenAiChatModel model;     @RequestMapping(&quot;/chat&quot;)    public String chat(String message)&#123;        String result = model.chat(message);        return result;    &#125;&#125;\n\n\n3.AIService 工具类  AIService工具类是用于调用大模型的，前面例子用于调用大模型的方式不太常用，因为比较麻烦。AIService整合了很多高级功能，比如会话记忆、RAG知识库等等，如果调用chat方法，这些工具都需要自己编写，比较麻烦。\n\nAIService工具类使用方法\n引入AIService依赖\n声明封装聊天的接口   public interface ConsultantService &#123;//用于聊天的方法,message为用户输入的内容public String chat(String message);&#125;\n创建动态代理对象 //config配置类@Configuration  public class CommonConfig &#123;  @Autowired  private OpenAiChatModel model;  @Bean           public ConsultantService consultantService() &#123;      ConsultantService cs = AiServices.builder(ConsultantService.class)              .chatModel(model)//设置对话时使用的模型对象              .build();      return cs;    &#125;  &#125;\n编写controller层并注入service层使用   @RestControllerpublic class ChatController &#123;@Autowiredprivate ConsultantService consultantService;@RequestMapping(&quot;/chat&quot;)public String chat(String message)&#123;    String result = consultantService.chat(message);    return result;  &#125;&#125;\n\n\nAIService工具类声明使用  为了简化 AIService类的使用， Langchain4j提供了声明式使用的方法，使用注解， Langchain4j会自动创建代理对象注入到容器。  修改后的service层：    @AiService (  wiringMode = AiServiceWiringMode.EXPLICIT,  chatModel = &quot;openAiChatModel&quot;)public interface ConsultantService &#123;  //用于聊天的方法,message为用户输入的内容  public String chat(String message);&#125;  解释：    wiringMode：    用于装配模式，默认取值是AiServiceWiringMode.AUTOMATIC，是自动装配。AiServiceWiringMode.EXPLICIT是手动装配。    chatModel：指定需要使用的模型对象名，首字母小写。  但这两个属性也可以不手动设置，直接加@AIService\n4. 流式调用  调用大模型有两种方法，一是阻塞调用，而是流式调用。区别就是流式调用是大模型生成一点内容就返回到客户端。阻塞式就是一次性响应。\n  流式调用方式：\n\n引入依赖\n在配置文件中配置流式模型的信息\n调整上述service层代码，流式调用的返回值类型与阻塞式不一样，是Flux类型。\n\n  @AiService(      wiringMode = AiServiceWiringMode.EXPLICIT,      chatModel = &quot;openAiChatModel&quot;,      streamingChatModel = &quot;openAiStreamingChatModel&quot;)public interface ConsultantService &#123;  public Flux&lt;String&gt; chat(String message);&#125;\n\n调整controller层的代码，要修改mapping路径的produces，防止乱码，然后修改返回类型。\n\n  @RestControllerpublic class ChatController &#123;  @Autowired  private ConsultantService consultantService;  @RequestMapping(value = &quot;/chat&quot;,produces = &quot;text/html;charset=utf-8&quot;)  public Flux&lt;String&gt; chat(String memoryId,String message)&#123;      Flux&lt;String&gt; result = consultantService.chat(memoryId,message);      return result;  &#125;  &#125;\n\n5. 消息注解  此注解用于，当用户问一些与该功能无关的时候，需要设置系统信息回复，而不予回答。消息注解用于设定系统消息。Langchain4j提供了两种消息注解，一个是SystemMessage, 另外一个是UserMessage。\n\nSystemMessage用于设置系统消息，在service接口添加该注解  @SystemMessage(fromResource = &quot;system.txt&quot;)  system.txt要导入到resources文件夹里，是提前设置好的系统信息内容。\nUserMessage可以完成同样效果  @UserMessage(&quot;这是系统信息。&#123;&#123;it&#125;&#125;&quot;)  通过&#123;&#123;it&#125;&#125;的方式动态获取到用户传递的信息，前面是预设的内容。\n\n6. 会话记忆  由于大模型本身不会有记忆，需要将上文对话内容一起发送给大模型，才能保证连贯的对话和准确的回答。我们需要实现会话记忆。  Langchain4j提供了一个ChatMemory接口可以用于添加记录。TokenWindowChatMemory和MessageWindowChatMemory是该接口的两个实现类。\n\n调用方法：\n实现接口\n\n  public interface ChatMemory &#123;  Object id();//记忆存储对象的唯一标识，用于记忆隔离  void add(ChatMessage var1);//添加一条会话记忆  List&lt;ChatMessage&gt; messages();//获取所有会话记忆  void clear();//清除所有会话记忆&#125;\n\n在配置类定义会话记忆对象\n\n  @Beanpublic ChatMemory chatMemory() &#123;  return MessageWindowChatMemory.builder()          .maxMessages(20)//最大保存的会话记录数量          .build();  &#125;\n\n在service层配置会话记忆对象\n\n  @AiService(      wiringMode = AiServiceWiringMode.EXPLICIT,      chatModel = &quot;openAiChatModel&quot;,      streamingChatModel = &quot;openAiStreamingChatModel&quot;,      chatMemory = &quot;chatMemory&quot;//配置会话记忆对象  )  ...\n\n记忆隔离  调用大模型的时候同时可能有很多用户，要保证不同用户之间的记忆要隔离开，存入不同的记忆对象中，在上述代码中提到的id方法就是用于记忆隔离。\n  以下为实现方法：\n\n定义记忆对象提供者(调用这个对象的get方法获取一个新的ChatMemory对象使用)\n\n  @Beanpublic ChatMemoryProvider chatMemoryProvider() &#123;    ChatMemoryProvider chatMemoryProvider = new ChatMemoryProvider() &#123;        @Override        public ChatMemory get(Object memoryId) &#123;            return MessageWindowChatMemory.builder()                    .id(memoryId)//id值                    .maxMessages(20)//最大会话记录数量                    .build();        &#125;    &#125;;    return chatMemoryProvider;  &#125;\n\n配置记忆对象提供者  仅需将上述改成chatMemoryProvider = &quot;chatMemoryProvider&quot;//配置记忆对象提供者\n在service层添加参数memoryId\n\n  public interface ConsultantService &#123;  @SystemMessage(fromResource = &quot;system.txt&quot;)  public Flux&lt;String&gt; chat(@MemoryId String memoryId, @UserMessage String message);  &#125;\n\n在controller层添加传递的memoryId\n\n  @RequestMapping(value = &quot;/chat&quot;,produces = &quot;text/html;charset=utf-8&quot;)public Flux&lt;String&gt; chat(String memoryId,String message)&#123;  Flux&lt;String&gt; result = consultantService.chat(memoryId,message);  return result;&#125;\n\n会话记忆持久化  由于MessageWindowChatMemory的add方法添加记忆时，是存储到ChatMemoryStore这个接口，这个接口简单来说就是把会话记录存储到内存里，服务器重启后会丢失。会话记忆持久化可以将记忆存储到外部服务器当中。  将会话记忆存储到redis中的步骤\n\n引入redis依赖\n在配置文件配置redis连接信息\n定义实现ChatMemory接口，重写getMessages、updateMessages、deleteMessages方法，用于操作redis，并且把实现类的对象注入到IOC容器中。\n\n  @Repository  public class RedisChatMemoryStore implements ChatMemoryStore &#123;    @Autowired    private StringRedisTemplate redisTemplate;//注入RedisTemplate    @Override    public List&lt;ChatMessage&gt; getMessages(Object memoryId) &#123;        //获取会话消息        String json = redisTemplate.opsForValue().get(memoryId);        //把json字符串转化成List&lt;ChatMessage&gt;        List&lt;ChatMessage&gt; list = ChatMessageDeserializer.messagesFromJson(json);        return list;    &#125;    @Override    public void updateMessages(Object memoryId, List&lt;ChatMessage&gt; list) &#123;        //更新会话消息        //1.把list转换成json数据        String json = ChatMessageSerializer.messagesToJson(list);        //2.把json数据存储到redis中        redisTemplate.opsForValue().set(memoryId.toString(),json, Duration.ofDays(1));    &#125;    @Override    public void deleteMessages(Object memoryId) &#123;        //删除会话消息        redisTemplate.delete(memoryId.toString());    &#125;    &#125;\n\n配置ChatMemoryStore，仅需在配置类改成.chatMemoryStore(redisChatMemoryStore)//配置ChatMemoryStore\n\n小结上述几个工具已经能基本实现调用大模型的功能，涉及到RAG知识库和Tools的一部分后续会加深学习。\n","tags":["学习记录"]},{"title":"Hello World","url":"/2025/10/20/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"重新学习spring boot","url":"/2025/10/20/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0spring-boot/","content":"在大二下的时候系统地学习过一段时间的 Spring Boot 和 Spring Cloud。Spring Boot 跟着完成了一个简单的外卖系统。不过过去时间太长，有些知识点忘了，这几天又重新翻了一下。\n\n一、Spring Boot 的核心思想可以简单理解为一个大 Map：key = string, value = object项目里有很多类，Spring Boot 负责扫描并把它们放进这个容器中。通过注解 @Component、@Controller、@Service 等让框架识别并注册。\n\n二、常用注解\n@Controller：控制层，负责对外暴露接口。  \n\n@Service：业务层，包含具体逻辑。  \n\n@Mapper：数据访问层（MyBatis 提供）。  \n\nController 调用 Service  \nService 调用 Mapper 完成数据库 CRUD。\n\n\n@Autowired：自动注入，Spring 会为你找到匹配的 Bean。  \n\n@Configuration：标记配置类，等价于 XML 配置。  \n\n@Bean：写在配置类的方法上，把返回对象注册为 Bean（常用于引入第三方组件）。\n\n\n\n三、Web 常见注解\n@RestController：@Controller + @ResponseBody，返回 JSON。  \n@RequestMapping：定义路由，可以指定 URL 与请求方法。  \n@GetMapping  \n@PostMapping  \n@PutMapping  \n@DeleteMapping\n\n\n@RequestParam：获取请求参数。  \n@PathVariable：获取 URL 中的路径变量。\n\n\n以上内容算是一次快速复习，后面还会继续深入了解。\n","tags":["学习记录"]}]